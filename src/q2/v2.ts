import {
  Shape,
  Outcome,
  EncryptedStrategyGuide,
  EncryptedRound,
  parseInput,
  decryptOpponentsShape,
  calculateOutcomePoints,
  calculateRoundShapePoints,
} from './shared';

type RoundV2 = { opponentsShape: Shape; outcome: Outcome };
type StrategyGuideV2 = RoundV2[];

/** @returns Number of points generated by playing the provided encrypted strategy guide using "V2" decryption
 *  @param inputContents - String representing the encrypted strategy guide's contents */
export function calculateEncryptedStrategyGuidePointsV2(inputContents: string): number {
  const encryptedGuide: EncryptedStrategyGuide = parseInput(inputContents);
  const decryptedGuide: StrategyGuideV2 = decryptStrategyGuideV2(encryptedGuide);
  return calculateStrategyGuidePointsV2(decryptedGuide);
}

/** @returns New strategy guide object with decrypted shape values using "V2" decryption */
function decryptStrategyGuideV2(encryptedGuide: EncryptedStrategyGuide): StrategyGuideV2 {
  return encryptedGuide.map((round: EncryptedRound) => ({
    opponentsShape: decryptOpponentsShape(round[0]),
    outcome: decryptOutcome(round[1]),
  }));
}

/** @returns Decrypted shape value */
function decryptOutcome(encryptedOutcome: string): Outcome {
  switch (encryptedOutcome) {
    case 'X':
      return Outcome.Loss;
    case 'Y':
      return Outcome.Draw;
    case 'Z':
      return Outcome.Win;
    default:
      throw Error(`Invalid encrypted outcome: '${encryptedOutcome}'`);
  }
}

/** @returns Number of points generated by playing an entire strategy guide using "V2" decryption */
function calculateStrategyGuidePointsV2(guide: StrategyGuideV2): number {
  return guide.reduce((points: number, round: RoundV2) => points + calculateRoundPointsV2(round), 0);
}

/** @returns Number of points generated by playing a single round using "V2" decryption */
function calculateRoundPointsV2(round: RoundV2): number {
  const responseShape: Shape = Shape.Rock; // TODO
  return calculateOutcomePoints(round.outcome) + calculateRoundShapePoints(responseShape);
}
