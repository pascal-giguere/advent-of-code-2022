import {
  Shape,
  Outcome,
  EncryptedStrategyGuide,
  EncryptedRound,
  parseInput,
  decryptOpponentsShape,
  calculateRoundShapePoints,
  calculateOutcomePoints,
} from './shared';

type RoundV1 = { opponentsShape: Shape; responseShape: Shape };
type StrategyGuideV1 = RoundV1[];

/** @returns Number of points generated by playing the provided encrypted strategy guide using "V1" decryption
 *  @param inputContents - String representing the encrypted strategy guide's contents */
export function calculateEncryptedStrategyGuidePointsV1(inputContents: string): number {
  const encryptedGuide: EncryptedStrategyGuide = parseInput(inputContents);
  const decryptedGuide: StrategyGuideV1 = decryptStrategyGuideV1(encryptedGuide);
  return calculateStrategyGuidePointsV1(decryptedGuide);
}

/** @returns New strategy guide object with decrypted shape values using "V1" decryption */
function decryptStrategyGuideV1(encryptedGuide: EncryptedStrategyGuide): StrategyGuideV1 {
  return encryptedGuide.map((round: EncryptedRound) => ({
    opponentsShape: decryptOpponentsShape(round[0]),
    responseShape: decryptResponseShape(round[1]),
  }));
}

/** @returns Decrypted shape value */
function decryptResponseShape(encryptedShape: string): Shape {
  switch (encryptedShape) {
    case 'X':
      return Shape.Rock;
    case 'Y':
      return Shape.Paper;
    case 'Z':
      return Shape.Scissors;
    default:
      throw Error(`Invalid encrypted response shape: '${encryptedShape}'`);
  }
}

/** @returns Number of points generated by playing an entire strategy guide using "V1" decryption */
function calculateStrategyGuidePointsV1(guide: StrategyGuideV1): number {
  return guide.reduce((points: number, round: RoundV1) => points + calculateRoundPointsV1(round), 0);
}

/** @returns Number of points generated by playing a single round using "V1" decryption */
function calculateRoundPointsV1(round: RoundV1): number {
  return calculateRoundOutcomePoints(round) + calculateRoundShapePoints(round.responseShape);
}

/** @returns Number of points generated for the "outcome" portion of a round */
function calculateRoundOutcomePoints(round: RoundV1): number {
  const outcome: Outcome = calculateRoundOutcome(round);
  return calculateOutcomePoints(outcome);
}

/** @returns Outcome of a single round */
function calculateRoundOutcome(round: RoundV1): Outcome {
  if (round.opponentsShape === round.responseShape) {
    return Outcome.Draw;
  }
  switch (round.opponentsShape) {
    case Shape.Rock:
      return round.responseShape === Shape.Paper ? Outcome.Win : Outcome.Loss;
    case Shape.Paper:
      return round.responseShape === Shape.Scissors ? Outcome.Win : Outcome.Loss;
    case Shape.Scissors:
      return round.responseShape === Shape.Rock ? Outcome.Win : Outcome.Loss;
  }
}
