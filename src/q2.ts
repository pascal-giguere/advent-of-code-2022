type EncryptedRound = { opponentsShape: string; responseShape: string };
type EncryptedStrategyGuide = EncryptedRound[];

type Round = { opponentsShape: Shape; responseShape: Shape };
type StrategyGuide = Round[];

enum Shape {
  Rock = 'rock',
  Paper = 'paper',
  Scissors = 'scissors',
}

/** @returns Number of points generated by playing the provided encrypted strategy guide
 *  @param inputContents - String representing the encrypted strategy guide's contents */
export function calculateEncryptedStrategyGuidePoints(inputContents: string): number {
  const encryptedGuide: EncryptedStrategyGuide = parseInput(inputContents);
  const decryptedGuide: StrategyGuide = decryptStrategyGuide(encryptedGuide);
  return calculateStrategyGuidePoints(decryptedGuide);
}

/** @returns Parsed input file with no data transform applied */
function parseInput(inputContents: string): EncryptedStrategyGuide {
  const inputLines: string[] = inputContents.split('\n').filter((l) => !!l);
  return inputLines.map(parseInputLine);
}

/** @returns Parsed line from input file with no data transform applied */
function parseInputLine(line: string): EncryptedRound {
  const splitLine = line.split(' ');
  if (splitLine.length !== 2) {
    throw Error(`Invalid input line: '${line}'`);
  }
  return {
    opponentsShape: splitLine[0],
    responseShape: splitLine[1],
  };
}

/** @returns New strategy guide object with decrypted shape values */
function decryptStrategyGuide(encryptedGuide: EncryptedStrategyGuide): StrategyGuide {
  return encryptedGuide.map((round: EncryptedRound) => ({
    opponentsShape: decryptOpponentsShape(round.opponentsShape),
    responseShape: decryptResponseShape(round.responseShape),
  }));
}

/** @returns Decrypted shape value */
function decryptOpponentsShape(encryptedShape: string): Shape {
  switch (encryptedShape) {
    case 'A':
      return Shape.Rock;
    case 'B':
      return Shape.Paper;
    case 'C':
      return Shape.Scissors;
    default:
      throw Error(`Invalid encrypted opponent's shape: '${encryptedShape}'`);
  }
}

/** @returns Decrypted shape value */
function decryptResponseShape(encryptedShape: string): Shape {
  switch (encryptedShape) {
    case 'X':
      return Shape.Rock;
    case 'Y':
      return Shape.Paper;
    case 'Z':
      return Shape.Scissors;
    default:
      throw Error(`Invalid encrypted response shape: '${encryptedShape}'`);
  }
}

/** @returns Number of points generated by playing an entire strategy guide */
function calculateStrategyGuidePoints(guide: StrategyGuide): number {
  return guide.reduce((points: number, round: Round) => points + calculateRoundPoints(round), 0);
}

/** @returns Number of points generated by playing a single round */
function calculateRoundPoints(round: Round): number {
  return calculateRoundOutcomePoints(round) + calculateRoundShapePoints(round.responseShape);
}

/** @returns Number of points generated for the "outcome" portion of a round */
function calculateRoundOutcomePoints(round: Round): number {
  if (round.opponentsShape === round.responseShape) {
    return 3;
  }
  switch (round.opponentsShape) {
    case Shape.Rock:
      return round.responseShape === Shape.Paper ? 6 : 0;
    case Shape.Paper:
      return round.responseShape === Shape.Scissors ? 6 : 0;
    case Shape.Scissors:
      return round.responseShape === Shape.Rock ? 6 : 0;
  }
}

/** @returns Number of points generated for the "shape" portion of a round */
function calculateRoundShapePoints(shape: Shape): number {
  switch (shape) {
    case Shape.Rock:
      return 1;
    case Shape.Paper:
      return 2;
    case Shape.Scissors:
      return 3;
  }
}
