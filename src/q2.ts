type EncryptedRound = [string, string];
type EncryptedStrategyGuide = EncryptedRound[];

type RoundV1 = { opponentsShape: Shape; responseShape: Shape };
type StrategyGuideV1 = RoundV1[];

type RoundV2 = { opponentsShape: Shape; outcome: Outcome };
type StrategyGuideV2 = RoundV2[];

enum Shape {
  Rock = 'rock',
  Paper = 'paper',
  Scissors = 'scissors',
}

enum Outcome {
  Win = 'win',
  Loss = 'loss',
  Draw = 'draw',
}

/** @returns Number of points generated by playing the provided encrypted strategy guide using "V1" decryption
 *  @param inputContents - String representing the encrypted strategy guide's contents */
export function calculateEncryptedStrategyGuidePointsV1(inputContents: string): number {
  const encryptedGuide: EncryptedStrategyGuide = parseInput(inputContents);
  const decryptedGuide: StrategyGuideV1 = decryptStrategyGuideV1(encryptedGuide);
  return calculateStrategyGuidePointsV1(decryptedGuide);
}

/** @returns Number of points generated by playing the provided encrypted strategy guide using "V2" decryption
 *  @param inputContents - String representing the encrypted strategy guide's contents */
export function calculateEncryptedStrategyGuidePointsV2(inputContents: string): number {
  const encryptedGuide: EncryptedStrategyGuide = parseInput(inputContents);
  const decryptedGuide: StrategyGuideV2 = decryptStrategyGuideV2(encryptedGuide);
  return calculateStrategyGuidePointsV2(decryptedGuide);
}

/** @returns Parsed input file with no data transform applied */
function parseInput(inputContents: string): EncryptedStrategyGuide {
  const inputLines: string[] = inputContents.split('\n').filter((l) => !!l);
  return inputLines.map(parseInputLine);
}

/** @returns Parsed line from input file with no data transform applied */
function parseInputLine(line: string): EncryptedRound {
  const splitLine = line.split(' ');
  if (splitLine.length !== 2) {
    throw Error(`Invalid input line: '${line}'`);
  }
  return splitLine as [string, string];
}

/** @returns New strategy guide object with decrypted shape values using "V1" decryption */
function decryptStrategyGuideV1(encryptedGuide: EncryptedStrategyGuide): StrategyGuideV1 {
  return encryptedGuide.map((round: EncryptedRound) => ({
    opponentsShape: decryptOpponentsShape(round[0]),
    responseShape: decryptResponseShape(round[1]),
  }));
}

/** @returns New strategy guide object with decrypted shape values using "V2" decryption */
function decryptStrategyGuideV2(encryptedGuide: EncryptedStrategyGuide): StrategyGuideV2 {
  return encryptedGuide.map((round: EncryptedRound) => ({
    opponentsShape: decryptOpponentsShape(round[0]),
    outcome: decryptOutcome(round[1]),
  }));
}

/** @returns Decrypted shape value */
function decryptOpponentsShape(encryptedShape: string): Shape {
  switch (encryptedShape) {
    case 'A':
      return Shape.Rock;
    case 'B':
      return Shape.Paper;
    case 'C':
      return Shape.Scissors;
    default:
      throw Error(`Invalid encrypted opponent's shape: '${encryptedShape}'`);
  }
}

/** @returns Decrypted shape value */
function decryptResponseShape(encryptedShape: string): Shape {
  switch (encryptedShape) {
    case 'X':
      return Shape.Rock;
    case 'Y':
      return Shape.Paper;
    case 'Z':
      return Shape.Scissors;
    default:
      throw Error(`Invalid encrypted response shape: '${encryptedShape}'`);
  }
}

/** @returns Decrypted shape value */
function decryptOutcome(encryptedOutcome: string): Outcome {
  switch (encryptedOutcome) {
    case 'X':
      return Outcome.Loss;
    case 'Y':
      return Outcome.Draw;
    case 'Z':
      return Outcome.Win;
    default:
      throw Error(`Invalid encrypted outcome: '${encryptedOutcome}'`);
  }
}

/** @returns Number of points generated by playing an entire strategy guide using "V1" decryption */
function calculateStrategyGuidePointsV1(guide: StrategyGuideV1): number {
  return guide.reduce((points: number, round: RoundV1) => points + calculateRoundPointsV1(round), 0);
}

/** @returns Number of points generated by playing an entire strategy guide using "V2" decryption */
function calculateStrategyGuidePointsV2(guide: StrategyGuideV2): number {
  return guide.reduce((points: number, round: RoundV2) => points + calculateRoundPointsV2(round), 0);
}

/** @returns Number of points generated by playing a single round using "V1" decryption */
function calculateRoundPointsV1(round: RoundV1): number {
  return calculateRoundOutcomePoints(round) + calculateRoundShapePoints(round.responseShape);
}

/** @returns Number of points generated by playing a single round using "V2" decryption */
function calculateRoundPointsV2(round: RoundV2): number {
  const responseShape: Shape = Shape.Rock; // TODO
  return calculateOutcomePoints(round.outcome) + calculateRoundShapePoints(responseShape);
}

/** @returns Number of points generated for the "outcome" portion of a round */
function calculateRoundOutcomePoints(round: RoundV1): number {
  const outcome: Outcome = calculateRoundOutcome(round);
  return calculateOutcomePoints(outcome);
}

/** @returns Outcome of a single round */
function calculateRoundOutcome(round: RoundV1): Outcome {
  if (round.opponentsShape === round.responseShape) {
    return Outcome.Draw;
  }
  switch (round.opponentsShape) {
    case Shape.Rock:
      return round.responseShape === Shape.Paper ? Outcome.Win : Outcome.Loss;
    case Shape.Paper:
      return round.responseShape === Shape.Scissors ? Outcome.Win : Outcome.Loss;
    case Shape.Scissors:
      return round.responseShape === Shape.Rock ? Outcome.Win : Outcome.Loss;
  }
}

/** @returns Number of points generated for the "outcome" portion of a round */
function calculateOutcomePoints(outcome: Outcome): number {
  switch (outcome) {
    case Outcome.Win:
      return 6;
    case Outcome.Loss:
      return 0;
    case Outcome.Draw:
      return 3;
  }
}

/** @returns Number of points generated for the "shape" portion of a round */
function calculateRoundShapePoints(shape: Shape): number {
  switch (shape) {
    case Shape.Rock:
      return 1;
    case Shape.Paper:
      return 2;
    case Shape.Scissors:
      return 3;
  }
}
